@Library(['mpp_service']) _

pipeline  {
    agent any

    parameters {
        string(
            name: 'BASE_URL',
            defaultValue: '',
            description: 'Link to FP package Repository')
        string(
            name: 'NE_TECH',
            defaultValue: '',
            description: 'NE technology filter(split by comma). Such as: SBTS,LTE')
        string(
            name: 'NE_RELEASE',
            defaultValue: '',
            description: '(Optional)NE release filter(split by comma).')
    }
    options {
        buildDiscarder(logRotator(numToKeepStr: '50', artifactNumToKeepStr: '50'))
        timestamps()
        timeout(time: 1, unit: 'HOURS')
    }
    triggers {
        cron('H/30 * * * *')
    }

    stages {
        stage('Search Package') {
            steps {
                script {
                    env.WORKSPACE = pwd()

                    def props = readProperties(file: "${env.WORKSPACE}/configuration/pulling_parameter.properties")

                    if (!BASE_URL) {
                        BASE_URL = props['BASE_URL']
                        println("Input parameter BASE_URL is empty, using value: [${BASE_URL}] in configuration file")
                    }
                    if (!NE_RELEASE) {
                        NE_RELEASE = props['NE_RELEASE']
                        println("Input parameter NE_RELEASE is empty, using value: [${NE_RELEASE}] in configuration file")
                    }
                    if (!NE_TECH) {
                        NE_TECH = props['NE_TECH']
                        println("Input parameter NE_TECH is empty, using value: [${NE_TECH}] in configuration file")
                    }
                    DOWNSTREAM_JOB_NAME = props['DOWNSTREAM_JOB_NAME']
                    println("For DOWNSTREAM_JOB_NAME, using value: $props[DOWNSTREAM_JOB_NAME] in configuration file")

                    ARTIFACT_CREDENTIAL_NAME = props['ARTIFACT_CREDENTIAL_NAME']
                    println("For ARTIFACT_CREDENTIAL_NAME, using value: [${ARTIFACT_CREDENTIAL_NAME}] in configuration file")
                }

                script {
                    if (!BASE_URL || !NE_TECH || !DOWNSTREAM_JOB_NAME || !ARTIFACT_CREDENTIAL_NAME) {
                        currentBuild.result = 'ABORTED'
                        error('Parameters(BASE_URL, NE_TECH, DOWNSTREAM_JOB_NAME, ARTIFACT_CREDENTIAL_NAME) is mandatory')
                    }
                    println('Use the following parameters to pull FP package:')
                    println("BASE_URL: ${BASE_URL}")
                    println("NE_TECH: ${NE_TECH}")
                    println("DOWNSTREAM_JOB_NAME: ${DOWNSTREAM_JOB_NAME}")
                    println("ARTIFACT_CREDENTIAL_NAME: ${ARTIFACT_CREDENTIAL_NAME}")
                }

                script {
                    def exitValue =  withCredentials([usernameColonPassword(credentialsId: ARTIFACT_CREDENTIAL_NAME, variable: 'USERPASS')]) {
                        sh(script: "chmod a+x ${env.WORKSPACE}/checkPackage/searchPackage.sh; \
                            ${env.WORKSPACE}/checkPackage/searchPackage.sh ${BASE_URL} ${USERPASS} ${NE_TECH} ${NE_RELEASE}",
                            returnStatus: true)
                    }
                    println("return value ${exitValue}")

                    if(exitValue != 0) {
                        error("Execute script failed. Stop building")
                    }

                    String packageContent = readFile("${env.WORKSPACE}/checkPackage/package.json")

                    println("The query output is: ${packageContent}")
                    def resultObj = parseJson(packageContent)
                    def linkContent = ""
                    for (pack in resultObj['results']) {
                        linkContent = linkContent + BASE_URL + '/' + pack['repo'] + '/' + pack['path'] + '/' + pack['name'] + "\n"
                    }
                    writeFile(file: "${env.WORKSPACE}/checkPackage/packageLinks.txt", text: linkContent)
                }
            }
        }
        stage('Trigger downstream pipeline') {
            steps {
                script {
                    env.WORKSPACE = pwd()
                    println("checking file ${env.WORKSPACE}/checkPackage/packageLinks.txt")

                    final String content = readFile("${env.WORKSPACE}/checkPackage/packageLinks.txt")
                    final List links = getDownstreamLinks(content)
                    
                    if (links.size() == 0) {
                        println("No new package ready for SyVe")
                    } else {
                        println("Start to trigger the next pipeline!")
                        
                        for(link in links) {
                            println("Trigger next pipeline \"${DOWNSTREAM_JOB_NAME}\" with parameter: \"${link}\"")
                            build(job: "${DOWNSTREAM_JOB_NAME}",
                                parameters: [string(name: 'FP_PACKAGE_LINK', value: "${link}")], 
                                quietPeriod: 0, propagate: false, wait: false)
                        }
                    }
                }
            }
        }
    }
}

@NonCPS
List getDownstreamLinks(final String content) {
    List links = []
    content.eachLine{ line -> 
        links << line
    }
    
    return links
}

@NonCPS
def parseJson(def json) {
    try {
        return readJSON(text: json)
    } catch (Exception e) {
        error("Fail to parse data to json: ${json}\nException: ${e}")
        return ""
    }
}